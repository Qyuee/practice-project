### ANSI/ISO 표준 트랜잭션 격리 수준
- 동시에 여러 트랜잭션이 처리 될 때, 서로 얼마나 고립되어 질 것인지를 의미한다.
- 다수의 사용자가 동일한 리소스에 접근 할 때, 이를 고려해야한다.

#### 종류
1. READ UNCOMMITTED
```
커밋되지 않은 데이터를 읽을 수 있다.
트랜잭션 1이 데이터수정 중, 트랜잭션 2가 커밋되지 않은 데이터를 읽을 수 있음 (Dirty Read)
이 때, 트랜잭션 1이 롤백되면 트랜잭션 2는 데이터의 일관성이 깨지는 이슈가 발생 할 수 있음

Dirty Read
- 다른 트랜잭션이 수정하고 commit하지 않은 더러운(?) 데이터를 읽어버린다.
- 같은 쿼리임에도 상태가 일관적이지 않은 이슈를 발생시킬 수 있다.
```

2. READ COMMITED (★Spring JPA 추천)
```
커밋된 상태의 데이터만 읽어들인다.
NON-REPEATABLE READ는 발생 할 수 있다.
트랜잭션 1이 데이터를 조회하는 중, 트랜잭션 2가 데이터를 수정하고 커밋. 그 후에 트랜잭션 1에서
다시 데이터를 조회하면 변경된 데이터가 읽어진다.
```

3. REPEATABLE READ (MySQL의 기본 값)
```
트랜잭션이 시작되기전에 커밋된 데이터만 읽을 수 있다.
NON-REPEATABLE READ가 발생하지 않는다.

1. Update 부정합 발생 가능
 - 1번 트랙잭션 시작 'hello'를 검색한다. -> 존재
 - 2번 트랜잭션 시작 'hello'를 검색하고 'wrold'로 수정하고 commit한다.
 - 1번 트랜잭션에서 검색된 'hello'를 'bye'로 수정하고 commit 한다.
   -> 근데 이미 'hello'는 트랜잭션2에 의해서 변경되었으므로 존재하지 않는다.
 - 1번은 'hello'를 'bye'로 변경 할 수 없다.

2. Phantom(유령) READ 발생 가능
 - 1번 트랜잭션에서 'hello'를 검색한다. -> 없다.
 - 2번 트랜잭션에서 'hello'를 입력하고 commit 한다.
 - 1번 트랜잭션에서 다시 'hello'를 검색하고 commit 한다. -> 있다.
 없던 데이터가 유령과 같이 등장했다.
 (delete에서는 이러한 현상은 나타나지 않는다.)
```

4. SERIALIZABLE
```
가장 엄격한 격리 수준.
읽기/쓰기 작업에 모두 잠금(lock)을 걸어버린다. -> 다른 트랜잭션이 읽지도 쓰지도 못한다,
동시처리 성능이 급격하게 떨어진다.
```